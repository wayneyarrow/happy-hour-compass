"use server";

import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/server";
import { ensureOperatorForSession } from "@/lib/ensureOperator";
import type { TaglineState, HhTimesState, HhItem, SpecialsState } from "./types";

// ─────────────────────────────────────────────────────────────────────────────
// Auth helper (same pattern as /admin/venue/actions.ts)
// ─────────────────────────────────────────────────────────────────────────────

async function resolveOperator() {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return {
      supabase,
      user: null,
      operator: null,
      operatorError: "Session expired. Please sign in again.",
    };
  }
  const { operator, error: operatorError } = await ensureOperatorForSession(
    supabase,
    user
  );
  return { supabase, user, operator, operatorError };
}

// ─────────────────────────────────────────────────────────────────────────────
// Update tagline (hh_tagline)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Saves the happy hour tagline for the current operator's venue.
 *
 * `venueId` is bound via `.bind(null, venueId)` — never read from FormData.
 * Dual ownership filter enforced.
 */
export async function updateTaglineAction(
  venueId: string,
  _prevState: TaglineState,
  formData: FormData
): Promise<TaglineState> {
  const hh_tagline =
    (formData.get("hh_tagline") as string | null)?.trim() ?? "";

  if (hh_tagline.length > 80) {
    return {
      errors: { hh_tagline: "Please keep the tagline under 80 characters." },
      values: { hh_tagline },
    };
  }

  const { supabase, operator, operatorError } = await resolveOperator();

  if (operatorError || !operator) {
    return {
      errors: {
        form: operatorError ?? "Could not resolve your operator account.",
      },
      values: { hh_tagline },
    };
  }

  const { error, count } = await supabase
    .from("venues")
    .update(
      {
        hh_tagline: hh_tagline || null,
        updated_by_operator_id: operator.id,
      },
      { count: "exact" }
    )
    .eq("id", venueId)
    .eq("created_by_operator_id", operator.id);

  if (error) {
    console.error("[updateTaglineAction] Update failed:", error);
    return {
      errors: { form: "Failed to save tagline. Please try again." },
      values: { hh_tagline },
    };
  }

  if (count === 0) {
    return {
      errors: {
        form: "Venue not found or you don't have permission to edit it.",
      },
      values: { hh_tagline },
    };
  }

  revalidatePath("/admin/happy-hours");
  return { success: true, values: { hh_tagline } };
}

// ─────────────────────────────────────────────────────────────────────────────
// Update happy hour times (hh_times)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Saves the plain-text weekly happy hour schedule generated by HhTimesForm.
 *
 * `venueId` is bound — never read from FormData.
 * Dual ownership filter enforced.
 */
export async function updateHhTimesAction(
  venueId: string,
  _prevState: HhTimesState,
  formData: FormData
): Promise<HhTimesState> {
  const hh_times = (formData.get("hh_times") as string | null)?.trim() ?? "";

  const { supabase, operator, operatorError } = await resolveOperator();

  if (operatorError || !operator) {
    return {
      errors: {
        form: operatorError ?? "Could not resolve your operator account.",
      },
    };
  }

  const { error, count } = await supabase
    .from("venues")
    .update(
      {
        hh_times: hh_times || null,
        updated_by_operator_id: operator.id,
      },
      { count: "exact" }
    )
    .eq("id", venueId)
    .eq("created_by_operator_id", operator.id);

  if (error) {
    console.error("[updateHhTimesAction] Update failed:", error);
    return {
      errors: { form: "Failed to save times. Please try again." },
    };
  }

  if (count === 0) {
    return {
      errors: {
        form: "Venue not found or you don't have permission to edit it.",
      },
    };
  }

  revalidatePath("/admin/happy-hours");
  return { success: true };
}

// ─────────────────────────────────────────────────────────────────────────────
// Shared validation helper for food / drink specials JSON payloads
// ─────────────────────────────────────────────────────────────────────────────

function validateAndParseItems(raw: string): {
  items: HhItem[];
  error?: string;
} {
  if (!raw.trim()) return { items: [] };

  let parsed: unknown;
  try {
    parsed = JSON.parse(raw);
  } catch {
    return { items: [], error: "Invalid data format. Please try again." };
  }

  if (!Array.isArray(parsed)) {
    return { items: [], error: "Invalid data format. Please try again." };
  }

  const items: HhItem[] = [];

  for (let i = 0; i < parsed.length; i++) {
    const item = parsed[i] as Record<string, unknown>;
    if (typeof item !== "object" || item === null) continue;

    const name = ((item.name as string | undefined) ?? "").trim();
    const price = ((item.price as string | undefined) ?? "").trim();
    const notes = ((item.notes as string | undefined) ?? "").trim();

    // Skip rows that are completely empty
    if (!name && !price && !notes) continue;

    if (!name) {
      return { items: [], error: `Row ${i + 1}: Item name is required.` };
    }
    if (name.length > 60) {
      return {
        items: [],
        error: `Row ${i + 1}: Item name must be 60 characters or fewer.`,
      };
    }
    if (price.length > 10) {
      return {
        items: [],
        error: `Row ${i + 1}: Price must be 10 characters or fewer.`,
      };
    }
    if (notes.length > 40) {
      return {
        items: [],
        error: `Row ${i + 1}: Notes must be 40 characters or fewer.`,
      };
    }

    items.push({
      name,
      ...(price ? { price } : {}),
      ...(notes ? { notes } : {}),
    });
  }

  return { items };
}

// ─────────────────────────────────────────────────────────────────────────────
// Update food specials (hh_food_details)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Saves JSON-encoded food specials for the current operator's venue.
 * Always writes JSON (even if the existing value was legacy plain text).
 *
 * `venueId` is bound — never read from FormData.
 * Dual ownership filter enforced.
 */
export async function updateFoodSpecialsAction(
  venueId: string,
  _prevState: SpecialsState,
  formData: FormData
): Promise<SpecialsState> {
  const raw = (formData.get("hh_food_details") as string | null) ?? "";
  const { items, error: parseError } = validateAndParseItems(raw);

  if (parseError) {
    return { errors: { form: parseError } };
  }

  const { supabase, operator, operatorError } = await resolveOperator();

  if (operatorError || !operator) {
    return {
      errors: {
        form: operatorError ?? "Could not resolve your operator account.",
      },
    };
  }

  const { error, count } = await supabase
    .from("venues")
    .update(
      {
        hh_food_details:
          items.length > 0 ? JSON.stringify(items) : null,
        updated_by_operator_id: operator.id,
      },
      { count: "exact" }
    )
    .eq("id", venueId)
    .eq("created_by_operator_id", operator.id);

  if (error) {
    console.error("[updateFoodSpecialsAction] Update failed:", error);
    return {
      errors: { form: "Failed to save food specials. Please try again." },
    };
  }

  if (count === 0) {
    return {
      errors: {
        form: "Venue not found or you don't have permission to edit it.",
      },
    };
  }

  revalidatePath("/admin/happy-hours");
  return { success: true };
}

// ─────────────────────────────────────────────────────────────────────────────
// Update drink specials (hh_drink_details)
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Saves JSON-encoded drink specials for the current operator's venue.
 * Always writes JSON (even if the existing value was legacy plain text).
 *
 * `venueId` is bound — never read from FormData.
 * Dual ownership filter enforced.
 */
export async function updateDrinkSpecialsAction(
  venueId: string,
  _prevState: SpecialsState,
  formData: FormData
): Promise<SpecialsState> {
  const raw = (formData.get("hh_drink_details") as string | null) ?? "";
  const { items, error: parseError } = validateAndParseItems(raw);

  if (parseError) {
    return { errors: { form: parseError } };
  }

  const { supabase, operator, operatorError } = await resolveOperator();

  if (operatorError || !operator) {
    return {
      errors: {
        form: operatorError ?? "Could not resolve your operator account.",
      },
    };
  }

  const { error, count } = await supabase
    .from("venues")
    .update(
      {
        hh_drink_details:
          items.length > 0 ? JSON.stringify(items) : null,
        updated_by_operator_id: operator.id,
      },
      { count: "exact" }
    )
    .eq("id", venueId)
    .eq("created_by_operator_id", operator.id);

  if (error) {
    console.error("[updateDrinkSpecialsAction] Update failed:", error);
    return {
      errors: { form: "Failed to save drink specials. Please try again." },
    };
  }

  if (count === 0) {
    return {
      errors: {
        form: "Venue not found or you don't have permission to edit it.",
      },
    };
  }

  revalidatePath("/admin/happy-hours");

  return { success: true };
}
